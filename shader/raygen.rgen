#version 460
#extension GL_NV_ray_tracing : require

layout(set = 0, binding = 0) uniform accelerationStructureNV tlas;
layout(set = 2, binding = 0, rgba8) uniform image2D output_image;

layout (set = 1, binding = 0) uniform View {
    mat4 inv_proj;
    mat4 inv_view;
} view;

struct RayPayload {
	vec4 color;
	float distance;
    float cos;
};

const int MAX_ITERATION = 50;

layout(location = 0) rayPayloadNV RayPayload pay_load;
layout(location = 1) rayPayloadNV vec4 global_origin;

vec4 blending(vec4 source, vec4 destination) {
    // color = (source_color * source_factor) op (destination_color * destination_factor)

    float source_factor = source.w;
    // float source_factor = 1.0;
    float destination_factor = (1.0 - source.w);

    vec3 color = (source.xyz * source_factor) + (destination.xyz * destination_factor);
    float alpha = source.w;

    return vec4(color, alpha);
}

void main() {
    const vec2 pixel_center = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 in_uv = pixel_center / vec2(gl_LaunchSizeNV.xy);
    vec2 d = in_uv * 2.0 - 1.0;

    vec4 origin = view.inv_view * vec4(0.0, 0.0, 0.0, 1.0);
    vec4 target = view.inv_proj * vec4(d.x, d.y, 1.0, 1.0);
    vec4 direction = view.inv_view * vec4(normalize(target.xyz), 0.0);

    vec4 color = imageLoad(output_image, ivec2(gl_LaunchIDNV.xy));

    uint ray_flags = gl_RayFlagsOpaqueNV;
    uint cull_mask = 0xff;
    const int pay_load_index = 0;
    int hit_shader_index = 0;
    int miss_shader_index = 0;
    int sbt_record_stride = 0;
    float tmin = 0.001;
    float tmax = 10000.0;

    global_origin = origin;
    int i = 0;

    for (; i < MAX_ITERATION; i++) {
        // cast a ray
        traceNV(
            tlas,
            ray_flags,
            cull_mask,
            hit_shader_index,
            sbt_record_stride,
            miss_shader_index,
            origin.xyz,
            tmin,
            direction.xyz,
            tmax,
            pay_load_index
        );

        // break if we haven't hit anything
        if (pay_load.distance < 0.0) {
            break;
        }

        if (pay_load.cos <= 0.0) {
            continue;
        }

        // vec4 cos_color = vec4(pay_load.color.xyz, pay_load.color.w * pay_load.cos);

        color = blending(pay_load.color, color);

        // break if color almost fully opaque
        if (color.w >= 0.97) {
            break;
        }

        // calculate new origin
        origin.xyz = origin.xyz + direction.xyz * (pay_load.distance + 0.001);
    }

    // set background color if we didn't hit anything
    // if (color == vec4(0.0)) {
    //     color = vec4(0.3, 0.3, 0.3, 1.0);
    // }

    imageStore(output_image, ivec2(gl_LaunchIDNV.xy), color);
}